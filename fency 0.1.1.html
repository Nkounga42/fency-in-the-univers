<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Jeu de Vaisseau Spatial - Minimap Circulaire</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #000;
                font-family: Arial, sans-serif;
            }

            canvas {
                display: block;
            }

            #instructions,
            #debug {
                position: absolute;
                top: 10px;
                left: 10px;
                color: white;
                background-color: rgba(0, 0, 0, 0.6);
                padding: 15px;
                border-radius: 5px;
                max-width: 400px;
                z-index: 100;
            }

            h2 {
                margin-top: 0;
                color: #00ffff;
            }

            .key {
                background-color: #333;
                border-radius: 3px;
                padding: 2px 6px;
                margin: 0 2px;
                font-family: monospace;
            }
        </style>
    </head>
    <body>
        <div id="debug"></div>
        <div id="instructions" hidden>
            <h2>Contrôles du Vaisseau Spatial</h2>
            <p><b>Clavier:</b></p>
            <ul>
                <li>
                    <span class="key">Z</span> ou <span class="key">↑</span> -
                    Avancer
                </li>
                <li>
                    <span class="key">Q</span> ou <span class="key">←</span> -
                    Tourner à gauche
                </li>
                <li>
                    <span class="key">D</span> ou <span class="key">→</span> -
                    Tourner à droite
                </li>
                <li>
                    <span class="key">S</span> ou <span class="key">↓</span> -
                    Freiner
                </li>
            </ul>
            <p><b>Souris:</b></p>
            <ul>
                <li>
                    <span class="key">M</span> - Activer/désactiver le contrôle
                    à la souris
                </li>
                <li>Déplacer la souris - Orienter le vaisseau</li>
                <li>Clic gauche - Accélérer</li>
            </ul>
        </div>

        <script>
            let debug = document.getElementById("debug");

            class Spaceship {
                constructor(x, y, game) {
                    this.game = game; // Stockez la référence au jeu
                    // Position du vaisseau
                    this.x = x;
                    this.y = y;

                    // Rotation du vaisseau (en degrés)
                    this.rotation = 0;

                    // Vitesse actuelle
                    this.speed = 0;
                    this.maxSpeed = 10;
                    this.acceleration = 0.1;
                    this.deceleration = 0.05;
                    this.isDestroyed = false;
                    // Variables de contrôle
                    this.moveForward = false;
                    this.rotateLeft = false;
                    this.rotateRight = false;
                    this.brake = false;
                    this.energy = 100; // Énergie actuelle
                    this.maxEnergy = 100; // Énergie maximale
                    // Variables pour le contrôle de la souris
                    this.mouseControl = false;
                    this.targetX = x;
                    this.targetY = y;
                    this.rotationSpeed = 3;

                    // Dimensions du vaisseau
                    this.width = 30 / 1.5;
                    this.height = 50 / 1.5;

                    // Couleur du vaisseau
                    this.color = "#00FFFF";

                    // Projectiles
                    this.projectiles = [];
                    this.fireCooldown = 0;
                    this.fireRate = 4; // Plus la valeur est basse, plus le tir est rapide

                    // Points de vie
                    this.health = 100;
                    this.maxHealth = 100;

                    // Liaison des événements clavier et souris
                    this.setupControls();
                }

                setupControls() {
                    // Gestion des touches du clavier (appui)
                    document.addEventListener("keydown", (e) => {
                        if (this.game && this.game.paused) return; // Blocage en pause
                        switch (e.key) {
                            case "z":
                            case "ArrowUp":
                                this.moveForward = true;
                                break;
                            case "q":
                            case "ArrowLeft":
                                this.rotateLeft = true;
                                break;
                            case "d":
                            case "ArrowRight":
                                this.rotateRight = true;
                                break;
                            case "s":
                            case "ArrowDown":
                                this.brake = true;
                                break;
                            case "m":
                                // Activer/désactiver le contrôle à la souris
                                this.mouseControl = !this.mouseControl;
                                console.log(
                                    "Contrôle souris: " +
                                        (this.mouseControl
                                            ? "activé"
                                            : "désactivé")
                                );
                                break;
                            case " ":
                                // Tirer un projectile avec la barre d'espace
                                this.fire();
                                break;
                        }
                    });

                    // Gestion des touches du clavier (relâchement)
                    document.addEventListener("keyup", (e) => {
                        switch (e.key) {
                            case "z":
                            case "ArrowUp":
                                this.moveForward = false;
                                break;
                            case "q":
                            case "ArrowLeft":
                                this.rotateLeft = false;
                                break;
                            case "d":
                            case "ArrowRight":
                                this.rotateRight = false;
                                break;
                            case "s":
                            case "ArrowDown":
                                this.brake = false;
                                break;
                        }
                    });

                    // Gestion de la souris
                    document.addEventListener("mousemove", (e) => {
                        if (this.game && this.game.paused) return; // Blocage en pause
                        if (this.mouseControl) {
                            // Mettre à jour la position cible
                            this.targetX = e.clientX;
                            this.targetY = e.clientY;
                        }
                    });

                    // Gestion du clic de souris
                    document.addEventListener("mousedown", (e) => {
                        if (this.game && this.game.paused) return; // Blocage en pause
                        // Tirer un projectile avec le clic de souris
                        this.fire();
                    });

                    document.addEventListener("mouseup", (e) => {
                        if (this.mouseControl) {
                            this.moveForward = false;
                        }
                    });
                }

                fire() {
                    if (this.game && this.game.paused) return;
                    if (this.fireCooldown <= 0) {
                        // Calcul de la position de départ du projectile (devant le vaisseau)
                        const angleRad = (this.rotation - 90) * (Math.PI / 180);
                        const startX =
                            this.x + Math.cos(angleRad) * (this.height / 2);
                        const startY =
                            this.y + Math.sin(angleRad) * (this.height / 2);

                        // Créer un nouveau projectile
                        const projectile = {
                            x: startX,
                            y: startY,
                            speed: 10, // Vitesse du projectile
                            angle: this.rotation,
                            life: 100, // Durée de vie du projectile (en frames)
                            damage: 10, // Dégâts infligés
                        };

                        this.projectiles.push(projectile);
                        this.fireCooldown = this.fireRate;
                    }
                }

                takeDamage(amount) {
                    if (this.isDestroyed) return;
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.health = 0;
                        const explosionSize =
                            this.radius * (1 + Math.random() * 0.5);
                        this.game.createExplosion(
                            this.x,
                            this.y,
                            explosionSize,
                            "#ffffff"
                        );
                        setTimeout(() => {
                            this.destroy(); // Retirer le vaisseau du jeu
                        }, 2000); // Retirer après

                        // Gérer la mort du joueur ici
                    }
                }
                destroy() {
                    this.isDestroyed = true;
                    // Ajoutez ici des effets visuels/sonores de destruction
                    console.log("Vaisseau détruit !");
                    this.game.createExplosion(this.x, this.y, 50); // À implémenter dans Game

                    // Optionnel : Désactiver les contrôles
                    this.moveForward = false;
                    this.rotateLeft = false;
                    this.rotateRight = false;
                    this.speed = 0;
                }
                updateProjectiles(game) {
                    // Mettre à jour les projectiles
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const p = this.projectiles[i];

                        // Calcul du déplacement
                        const angleRad = (p.angle - 90) * (Math.PI / 180);
                        p.x += Math.cos(angleRad) * p.speed;
                        p.y += Math.sin(angleRad) * p.speed;

                        // Décrémenter la durée de vie
                        p.life--;

                        // Vérifier les collisions avec les ennemis
                        for (let j = game.enemies.length - 1; j >= 0; j--) {
                            const enemy = game.enemies[j];
                            if (this.checkProjectileCollision(p, enemy)) {
                                enemy.takeDamage(p.damage);
                                this.projectiles.splice(i, 1);
                                break;
                            }
                        }

                        // Supprimer les projectiles qui ont expiré ou qui sont hors écran
                        if (
                            p.life <= 0 ||
                            p.x < -game.worldSize ||
                            p.x > game.worldSize * 2 ||
                            p.y < -game.worldSize ||
                            p.y > game.worldSize * 2
                        ) {
                            this.projectiles.splice(i, 1);
                        }
                    }

                    // Réduire le cooldown du tir
                    if (this.fireCooldown > 0) {
                        this.fireCooldown--;
                    }
                }

                checkProjectileCollision(projectile, enemy) {
                    // Simple collision circulaire
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    return distance < enemy.radius;
                }

                drawProjectiles(ctx, game) {
                    ctx.save();
                    ctx.fillStyle = "#FF0000"; // Couleur des projectiles

                    for (const p of this.projectiles) {
                        // Calculer la position à l'écran en tenant compte de la caméra
                        const screenX =
                            p.x - game.cameraOffsetX + game.canvas.width / 2;
                        const screenY =
                            p.y - game.cameraOffsetY + game.canvas.height / 2;

                        // Dessiner le projectile (un simple cercle)
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }

                drawHealthBar(ctx, game) {
                    const barWidth = 100;
                    const barHeight = 10;
                    const x = game.canvas.width / 2 - barWidth / 2;
                    const y = 20;

                    // Fond de la barre
                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                    ctx.fillRect(x, y, barWidth, barHeight);

                    // Barre de vie
                    const healthWidth =
                        (this.health / this.maxHealth) * barWidth;
                    ctx.fillStyle =
                        this.health > 50
                            ? "#00FF00"
                            : this.health > 20
                            ? "#FFFF00"
                            : "#FF0000";
                    ctx.fillRect(x, y, healthWidth, barHeight);

                    // Bordure
                    ctx.strokeStyle = "#FFFFFF";
                    ctx.strokeRect(x, y, barWidth, barHeight);
                }

                update(game) {
                    if (this.isDestroyed) return;
                    for (const enemy of game.enemies) {
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = this.width / 2 + enemy.radius;

                        if (distance < minDistance && distance > 0) {
                            // Répulsion
                            const force =
                                ((minDistance - distance) / minDistance) * 2;
                            this.x += (dx / distance) * force;
                            this.y += (dy / distance) * force;
                        }
                    }
                    // Mise à jour de la rodzdtation basée sur le clavier
                    if (!this.mouseControl) {
                        if (this.rotateLeft) {
                            this.rotation -= this.rotationSpeed;
                        }
                        if (this.rotateRight) {
                            this.rotation += this.rotationSpeed;
                        }
                    } else {
                        // Calcul de l'angle vers la position de la souris (sans ajustement de caméra)
                        const dx = this.targetX - game.canvas.width / 2;
                        const dy = this.targetY - game.canvas.height / 2;
                        const targetAngle =
                            Math.atan2(dy, dx) * (180 / Math.PI) + 90;

                        // Rotation progressive vers l'angle cible
                        let angleDiff = targetAngle - this.rotation;

                        // Normaliser la différence d'angle entre -180 et 180
                        while (angleDiff > 180) angleDiff -= 360;
                        while (angleDiff < -180) angleDiff += 360;

                        // Appliquer une rotation progressive
                        if (Math.abs(angleDiff) > 1) {
                            this.rotation +=
                                Math.sign(angleDiff) *
                                Math.min(
                                    this.rotationSpeed,
                                    Math.abs(angleDiff)
                                );
                        }
                    }

                    // Normaliser l'angle de rotation
                    this.rotation = this.rotation % 360;
                    if (this.rotation < 0) this.rotation += 360;

                    // Mise à jour de la vitesse
                    if (this.moveForward) {
                        this.speed = Math.min(
                            this.maxSpeed,
                            this.speed + this.acceleration
                        );
                    } else if (this.brake) {
                        this.speed = Math.max(
                            0,
                            this.speed - this.deceleration * 2
                        );
                    } else {
                        this.speed = Math.max(
                            0,
                            this.speed - this.deceleration
                        );
                    }

                    // Calcul des composantes de déplacement
                    const angleRad = (this.rotation - 90) * (Math.PI / 180);
                    const dx = Math.cos(angleRad) * this.speed;
                    const dy = Math.sin(angleRad) * this.speed;

                    // Mise à jour de la position
                    this.x += dx;
                    this.y += dy;

                    // Mettre à jour le décalage de la caméra en fonction du déplacement du vaisseau
                    game.cameraOffsetX += dx;
                    game.cameraOffsetY += dy;

                    // Mettre à jour les projectiles
                    this.updateProjectiles(game);
                }

                draw(ctx, game) {
                    if (this.isDestroyed) return;

                    // Dessiner les projectiles d'abord (pour qu'ils soient sous le vaisseau)
                    this.drawProjectiles(ctx, game);

                    // Dessiner le vaisseau
                    ctx.save();

                    // Dessiner le vaisseau au centre de l'écran
                    const screenX = game.canvas.width / 2;
                    const screenY = game.canvas.height / 2;

                    ctx.translate(screenX, screenY);
                    ctx.rotate((this.rotation * Math.PI) / 180);

                    // Dessiner le vaisseau
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height / 2); // Pointe du vaisseau
                    ctx.lineTo(-this.width / 2, this.height / 2); // Coin inférieur gauche
                    ctx.lineTo(0, this.height / 3); // Point milieu bas
                    ctx.lineTo(this.width / 2, this.height / 2); // Coin inférieur droit
                    ctx.closePath();
                    ctx.fill();

                    // Dessiner la propulsion si le vaisseau avance
                    if (this.moveForward) {
                        ctx.fillStyle = "#FF5500";
                        ctx.beginPath();
                        ctx.moveTo(-this.width / 4, this.height / 3);
                        ctx.lineTo(0, this.height / 2 + this.speed * 3);
                        ctx.lineTo(this.width / 4, this.height / 3);
                        ctx.closePath();
                        ctx.fill();
                    }

                    ctx.restore();

                    // Dessiner la barre de vie
                    this.drawHealthBar(ctx, game);
                }
            }

            // Classe pour les ennemis
            class Enemy {
                static TYPES = [
                    {
                        color: "red",
                        damage: 5,
                        radius: 15,
                        health: 40,
                        scoreValue: 5,
                        fireRate: 5,
                    },
                    {
                        color: "blue",
                        damage: 10,
                        radius: 20,
                        health: 60,
                        scoreValue: 10,
                        fireRate: 3,
                    },
                    {
                        color: "green",
                        damage: 15,
                        radius: 25,
                        health: 80,
                        scoreValue: 15,
                        fireRate: 3,
                    },
                    {
                        color: "yellow",
                        damage: 20,
                        radius: 30,
                        health: 100,
                        scoreValue: 20,
                        fireRate: 3,
                    },
                    {
                        color: "purple",
                        damage: 30,
                        radius: 35,
                        health: 130,
                        scoreValue: 30,
                        fireRate: 2,
                    },
                    {
                        color: "coral",
                        damage: 40,
                        radius: 40,
                        health: 150,
                        scoreValue: 50,
                        fireRate: 1,
                    },
                    {
                        color: "orange",
                        damage: 50,
                        radius: 45,
                        health: 200,
                        scoreValue: 100,
                        fireRate: 1,
                    },
                    {
                        color: "pink",
                        damage: 60,
                        radius: 50,
                        health: 250,
                        scoreValue: 150,
                        fireRate: 5,
                    },
                    {
                        color: "cyan",
                        damage: 60,
                        radius: 55,
                        health: 300,
                        scoreValue: 200,
                        fireRate: 3,
                    },
                    {
                        color: "lime",
                        damage: 70,
                        radius: 60,
                        health: 350,
                        scoreValue: 250,
                        fireRate: 2,
                    },
                    {
                        color: "magenta",
                        damage: 86,
                        radius: 65,
                        health: 400,
                        scoreValue: 300,
                        fireRate: 1,
                    },
                    {
                        color: "white",
                        damage: 88,
                        radius: 70,
                        health: 500,
                        scoreValue: 500,
                        fireRate: 5,
                    },
                ];

                constructor(game) {
                    this.game = game;

                    // Choisir un type d’ennemi aléatoirement
                    const type =
                        Enemy.TYPES[
                            Math.floor(Math.random() * Enemy.TYPES.length)
                        ];
                    this.color = type.color;
                    this.damage = type.damage;
                    this.radius = type.radius;
                    this.health = type.health;
                    this.maxHealth = type.health;
                    this.scoreValue = type.scoreValue;
                    this.fireCooldown = 0;
                    this.fireRate = Math.random() + type.fireRate * 100 * 2; // cadence de tire entre 1 et 3 sec

                    // Position aléatoire autour du joueurzzz
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 500 + Math.random() * 500;
                    this.x = this.game.spaceship.x + Math.cos(angle) * distance;
                    this.y = this.game.spaceship.y + Math.sin(angle) * distance;

                    // Mouvement
                    this.speed = 1 + Math.random() * 2;
                    this.rotation = 0;
                    this.rotationSpeed = 0.5 + Math.random();
                }
                shoot() {
                    const dx = this.game.spaceship.x - this.x;
                    const dy = this.game.spaceship.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    const projectile = new EnemyProjectile(
                        this.game,
                        this.x,
                        this.y,
                        angle
                    );
                    this.game.enemyProjectiles.push(projectile);
                }

                // Dans la classe Enemy ou dans un utilitaire
                checkCollision(other, minDistance) {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < minDistance;
                }
                update() {
                    // Même logique que toi pour suivre le joueur
                    const dx = this.game.spaceship.x - this.x;
                    const dy = this.game.spaceship.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const targetAngle =
                        Math.atan2(dy, dx) * (180 / Math.PI) + 90;

                    // Éviter les collisions entre ennemis
                    for (const otherEnemy of this.game.enemies) {
                        if (otherEnemy === this) continue;

                        const dx = this.x - otherEnemy.x;
                        const dy = this.y - otherEnemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = this.radius + otherEnemy.radius;

                        if (distance < minDistance && distance > 0) {
                            // Répulsion
                            const force =
                                ((minDistance - distance) / minDistance) * 2;
                            this.x += (dx / distance) * force;
                            this.y += (dy / distance) * force;
                        }
                    }
                    // Éviter la collision avec le joueur
                    const dxToPlayer = this.game.spaceship.x - this.x;
                    const dyToPlayer = this.game.spaceship.y - this.y;
                    const distanceToPlayer = Math.sqrt(
                        dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer
                    );
                    const minDistanceToPlayer =
                        this.radius + this.game.spaceship.width / 2;

                    if (distanceToPlayer < minDistanceToPlayer) {
                        // Répulsion
                        const force =
                            ((minDistanceToPlayer - distanceToPlayer) /
                                minDistanceToPlayer) *
                            2;
                        this.x -= (dxToPlayer / distanceToPlayer) * force;
                        this.y -= (dyToPlayer / distanceToPlayer) * force;
                    }
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > 180) angleDiff -= 360;
                    while (angleDiff < -180) angleDiff += 360;
                    if (Math.abs(angleDiff) > 1) {
                        this.rotation +=
                            Math.sign(angleDiff) *
                            Math.min(this.rotationSpeed, Math.abs(angleDiff));
                    }

                    if (distance > 100) {
                        const angleRad = (this.rotation - 90) * (Math.PI / 180);
                        this.x += Math.cos(angleRad) * this.speed;
                        this.y += Math.sin(angleRad) * this.speed;
                    }

                    if (
                        distance <
                        this.radius + this.game.spaceship.width / 2
                    ) {
                        //this.game.spaceship.takeDamage(this.damage /2); // Réduire les dégâts de collision *.5
                        // Ajoutez une répulsion pour éviter les collisions continues
                        const force = 5;
                        this.x -= (dxToPlayer / distanceToPlayer) * force;
                        this.y -= (dyToPlayer / distanceToPlayer) * force;
                    }

                    // Nouveau : Ne tirer que si le joueur est à une certaine distance
                    const fireDistance = 300; // Distance maximale pour tirer
                    if (distance < fireDistance) {
                        this.fireCooldown -= this.game.deltaTime;
                        if (this.fireCooldown <= 0) {
                            this.shoot();
                            this.fireCooldown = this.fireRate;
                        }
                    } else {
                        // Réinitialiser le cooldown si le joueur est trop loin
                        this.fireCooldown = this.fireRate;
                    }
                }
                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.health = 0;
                        this.game.score += this.scoreValue;
                        this.game.createExplosion(
                            this.x,
                            this.y,
                            this.radius * 2,
                            this.color
                        );
                    }
                }

                draw(ctx) {
                    const screenX =
                        this.x -
                        this.game.cameraOffsetX +
                        this.game.canvas.width / 2;
                    const screenY =
                        this.y -
                        this.game.cameraOffsetY +
                        this.game.canvas.height / 2;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate((this.rotation * Math.PI) / 180);

                    // Dessiner la zone de détection (optionnel)
                    ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
                    ctx.beginPath();
                    ctx.arc(0, 0, 300, 0, Math.PI * 2);
                    ctx.stroke();

                    // Dessiner l'ennemi
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius);
                    ctx.lineTo(-this.radius * 0.7, this.radius * 0.7);
                    ctx.lineTo(0, this.radius * 0.5);
                    ctx.lineTo(this.radius * 0.7, this.radius * 0.7);
                    ctx.closePath();
                    ctx.fill();

                    // Barre de vie
                    if (this.health < this.maxHealth) {
                        const barWidth = this.radius * 2;
                        const barHeight = 5;
                        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                        ctx.fillRect(
                            -barWidth / 2,
                            -this.radius - 10,
                            barWidth,
                            barHeight
                        );
                        const healthWidth =
                            (this.health / this.maxHealth) * barWidth;
                        ctx.fillStyle =
                            this.health > this.maxHealth * 0.5
                                ? "#00FF00"
                                : this.health > this.maxHealth * 0.2
                                ? "#FFFF00"
                                : "#FF0000";
                        ctx.fillRect(
                            -barWidth / 2,
                            -this.radius - 10,
                            healthWidth,
                            barHeight
                        );
                    }

                    ctx.restore();
                }
            }
            class EnemyProjectile {
                constructor(game, x, y, angle) {
                    this.game = game;
                    this.x = x;
                    this.y = y;
                    this.speed = 5;
                    this.radius = 5;
                    this.angle = angle; // en radians
                    this.damage = 5;
                    this.destroyed = false;
                    this.life = 360; // ← Nouveau : durée de vie en frames (2 sec à 60 FPS)
                }

                update() {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    // Décrémenter la durée de vie
                    this.life--;
                    if (this.life <= 0) {
                        this.destroyed = true;
                    }
                    // Collision avec le joueuro
                    const dx = this.x - this.game.spaceship.x;
                    const dy = this.y - this.game.spaceship.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (
                        distance <
                        this.radius + this.game.spaceship.width / 2
                    ) {
                        this.game.spaceship.takeDamage(this.damage);
                        this.destroyed = true;
                    }

                    // Supprimer si hors écran
                    const margin = 1000;
                    if (
                        Math.abs(this.x - this.game.spaceship.x) > margin ||
                        Math.abs(this.y - this.game.spaceship.y) > margin
                    ) {
                        this.destroyed = true;
                    }
                }

                draw(ctx) {
                    const screenX =
                        this.x -
                        this.game.cameraOffsetX +
                        this.game.canvas.width / 2;
                    const screenY =
                        this.y -
                        this.game.cameraOffsetY +
                        this.game.canvas.height / 2;
                    ctx.fillStyle = "#ff5555";
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            class FirstAidKit {
                constructor(game) {
                    this.game = game;
                    this.radius = 40;
                    this.healAmount = 100; // Énergie ou santé restaurée
                    this.spawnTime = Date.now();
                    this.lifespan = 100000; // Durée de vie en ms (15 secondes)
                    this.x = 0;
                    this.y = 0;
                    this.shouldBeRemoved = false; // Nouvelle propriété
                    this.spawnRandomPosition();
                    console.log("vous avez cree un kit de soin");
                }

                spawnRandomPosition() {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 200 + Math.random() * 300;
                    this.x =
                        (this.game.spaceship.x + Math.cos(angle) * distance) *
                        1;
                    //*2;
                    this.y =
                        (this.game.spaceship.y + Math.sin(angle) * distance) *
                        1;
                    //*2;
                }

                update() {
                    const dx = this.x - this.game.spaceship.x;
                    const dy = this.y - this.game.spaceship.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const collisionRadius =
                        this.radius + this.game.spaceship.width / 3;

                    if (distance < collisionRadius) {
                        this.game.spaceship.health = Math.min(
            this.game.spaceship.maxHealth,
            this.game.spaceship.health + this.healAmount
        );
        
        this.shouldBeRemoved = true;
        this.game.createExplosion(this.x, this.y, 30, "#00FF00");
        
        console.log("Santé restaurée !", this.game.spaceship.health);  
                    }

                    if (Date.now() - this.spawnTime > this.lifespan) {
                        this.shouldBeRemoved = true;
                    }
                }
                draw(ctx) {
                    const screenX =
                        this.x -
                        this.game.cameraOffsetX +
                        this.game.canvas.width / 2;
                    const screenY =
                        this.y -
                        this.game.cameraOffsetY +
                        this.game.canvas.height / 2;

                    // Dessin d'un éclair bleu (symbole d'énergie)
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.fillStyle = "#00AAFF";
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(5, 0);
                    ctx.lineTo(-5, 0);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(5, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();

                    // Animation de pulsation (corrigée pour éviter un rayon négatif)
                    const pulse =
                        Math.abs(Math.sin(Date.now() * 0.005)) * 2 + 1; // <-- Utilisation de Math.abs()
                    ctx.beginPath();
                    ctx.arc(
                        screenX,
                        screenY,
                        this.radius * pulse,
                        0,
                        Math.PI * 2
                    );
                    ctx.strokeStyle = "rgba(0, 200, 255, 0.3)";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            class Star {
                constructor(x, y, size, brightness, game) {
                    this.x = x;
                    this.y = y;
                    this.size = size;
                    this.brightness = brightness;

                    // Stocker les coordonnées d'origine pour le parallaxe
                    this.originalX = x;
                    this.originalY = y;

                    // Définir la couche de parallaxe (profondeur)
                    this.parallaxFactor = Math.random() * 0.8 + 0.2; // Entre 0.2 et 1.0

                    // Définir la taille du champ d'étoiles
                    this.fieldSize =
                        Math.max(game.canvas.width, game.canvas.height) * 3;
                }

                update(game) {
                    // Calculer la position de l'étoile en fonction du décalage de la caméra
                    // Les étoiles plus lointaines (parallaxFactor plus petit) bougent plus lentement
                    let adjustedX =
                        this.originalX -
                        game.cameraOffsetX * this.parallaxFactor;
                    let adjustedY =
                        this.originalY -
                        game.cameraOffsetY * this.parallaxFactor;

                    // Assurer que les étoiles restent visibles en créant un effet de tiling
                    const fieldSize = this.fieldSize;

                    // Effet de tiling pour que les étoiles apparaissent infiniment
                    adjustedX =
                        ((adjustedX % fieldSize) + fieldSize) % fieldSize;
                    adjustedY =
                        ((adjustedY % fieldSize) + fieldSize) % fieldSize;

                    // Repositionner par rapport au centre du canvas
                    adjustedX -= fieldSize / 2 - game.canvas.width / 2;
                    adjustedY -= fieldSize / 2 - game.canvas.height / 2;

                    this.x = adjustedX;
                    this.y = adjustedY;
                }

                draw(ctx) {
                    // Ne dessiner l'étoile que si elle est visible sur l'écran
                    if (
                        this.x >= -10 &&
                        this.x <= ctx.canvas.width + 10 &&
                        this.y >= -10 &&
                        this.y <= ctx.canvas.height + 10
                    ) {
                        // Faire clignoter légèrement les étoiles
                        const brightness =
                            0.5 +
                            (Math.sin(
                                Date.now() * 0.01 + this.brightness * 10
                            ) +
                                1) *
                                0.25;

                        ctx.fillStyle = `rgba(255, 255, 255, ${
                            brightness * this.parallaxFactor
                        })`;
                        ctx.beginPath();
                        ctx.arc(
                            this.x,
                            this.y,
                            this.size * this.parallaxFactor,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
            class Game {
                constructor() {
                    /// Initialisations de base
                    this.canvas = document.createElement("canvas");
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    document.body.appendChild(this.canvas);
                    this.ctx = this.canvas.getContext("2d");
                    this.gameOver = false;
                    // Propriétés du jeu

                    this.cameraOffsetX = 0;
                    this.cameraOffsetY = 0;
                    this.score = 0;
                    this.enemies = [];
                    this.enemyProjectiles = [];
                    this.lastEnemySpawn = 0;
                    this.enemySpawnRate = 8000;
                    this.paused = false;
                    this.showMinimap = true;
                    this.minimapRadius = 80;
                    this.lastTime = 0;
                    this.deltaTime = 0;
                    this.firstAidKits = []; // This is the correct initialization
                    this.explosions = []; // Initialisation des explosions
                    this.lastFirstAidSpawn = 0;
                    this.firstAidSpawnRate = 50000; // Toutes les 30 secondes// Toutes les 30 secondes

                    // Initialisations
                    this.initStars(500);
                    this.spaceship = new Spaceship(0, 0, this);

                    // Événements
                    window.addEventListener(
                        "resize",
                        this.handleResize.bind(this)
                    );
                    document.addEventListener(
                        "keydown",
                        this.handleKeyDown.bind(this)
                    );

                    this.gameLoop();
                    this.explosions = [];
                }

                createExplosion(x, y, size, color = "#FF5500") {
                    // Ajoutez le paramètre color
                    this.explosions.push({
                        x,
                        y,
                        size,
                        color, // Stockez la couleur
                        currentSize: 0,
                        maxSize: size,
                        duration: 1000,
                        startTime: Date.now(),
                    });
                }

                updateExplosions() {
                    const now = Date.now();
                    this.explosions = this.explosions.filter((explosion) => {
                        return now - explosion.startTime < explosion.duration;
                    });
                }

                drawExplosions(ctx) {
                    const now = Date.now();
                    this.explosions = this.explosions.filter((explosion) => {
                        const progress =
                            (now - explosion.startTime) / explosion.duration;
                        return progress < 1; // Garder tant que l'explosion est en cours
                    });

                    this.explosions.forEach((explosion) => {
                        const progress =
                            (now - explosion.startTime) / explosion.duration;
                        const size =
                            explosion.maxSize * Math.sin(progress * Math.PI);
                        const alpha = 1 - progress;

                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = explosion.color; // Utilisez la couleur stockée
                        ctx.beginPath();
                        ctx.arc(
                            explosion.x -
                                this.cameraOffsetX +
                                this.canvas.width / 2,
                            explosion.y -
                                this.cameraOffsetY +
                                this.canvas.height / 2,
                            size,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.restore();
                    });
                }
                // Méthodes organisées par ordre logique

                initStars(count) {
                    this.stars = [];
                    const fieldSize =
                        Math.max(this.canvas.width, this.canvas.height) * 3;

                    for (let i = 0; i < count; i++) {
                        const x =
                            Math.random() * fieldSize -
                            fieldSize / 2 +
                            this.canvas.width / 2;
                        const y =
                            Math.random() * fieldSize -
                            fieldSize / 2 +
                            this.canvas.height / 2;

                        this.stars.push(
                            new Star(
                                x,
                                y,
                                Math.random() * 2 + 0.5,
                                Math.random(),
                                this
                            )
                        );
                    }
                }

                updateEnemies() {
                    this.spawnEnemy();

                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        enemy.update();

                        if (enemy.health <= 0) {
                            this.enemies.splice(i, 1);
                        }
                    }
                }

                spawnEnemy() {
                    const now = Date.now();
                    if (now - this.lastEnemySpawn > this.enemySpawnRate) {
                        this.enemies.push(new Enemy(this));
                        this.lastEnemySpawn = now;
                        this.enemySpawnRate = Math.max(
                            500,
                            this.enemySpawnRate * 0.99
                        );
                    }
                }

                handleResize() {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }

                handleKeyDown(e) {
                    if (e.key === "p" || e.key === "P" || e.key === "Escape") {
                        this.togglePause();
                    }
                    if (
                        e.key === "F5" ||
                        e.keyCode === 116 ||
                        e.key.toLowerCase() === "r"
                    ) {
                        this.reset();
                    }
                }

                togglePause() {
                    this.paused = !this.paused;
                }

                gameLoop(timestamp) {
                    // Gestion du temps
                    this.deltaTime = timestamp - this.lastTime;
                    this.lastTime = timestamp;

                    // Effacer l'écran
                    this.ctx.fillStyle = "#000011";
                    this.ctx.fillRect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height
                    );

                    // Mises à jour (si pas en pause)
                    if (!this.paused && !this.gameOver) {
                        this.stars.forEach((star) => star.update(this));
                        this.spaceship.update(this);
                        this.updateEnemies();
                        this.drawExplosions(this.ctx);
                        this.spawnFirstAidKit();
                        this.updateFirstAidKits();
                        this.enemyProjectiles.forEach((p) => p.update());
                        this.enemyProjectiles = this.enemyProjectiles.filter(
                            (p) => !p.destroyed
                        );
                        this.firstAidKits.forEach((kit) => kit.draw(this.ctx));
                        // Vérifier si le vaisseau est détruit
                        if (this.spaceship.isDestroyed && !this.gameOver) {
                            this.gameOver = true;
                            console.log("Game Over !");
                        }
                    }

                    // Rendu
                    this.stars.forEach((star) => star.draw(this.ctx));
                    if (!this.spaceship.isDestroyed) {
                        this.spaceship.draw(this.ctx, this);
                    }
                    this.spaceship.draw(this.ctx, this);
                    this.enemies.forEach((enemy) => enemy.draw(this.ctx));
                    this.enemyProjectiles.forEach((p) => p.draw(this.ctx));
                    this.firstAidKits.forEach((kit) => kit.draw(this.ctx));
                    //if (this.showGrid) this.drawGrid();
                    if (this.showMinimap) this.drawCircularMinimap();
                    // Dans gameLoop(), avant le drawCircularMinimap()
                    console.log("Minimap visible:", this.showMinimap);
                    console.log("Nombre d'ennemis:", this.enemies.length);
                    console.log(
                        "Nombre de trousses:",
                        this.firstAidKits.length
                    );
                    this.drawDebugInfo();
                    // Afficher l'écran de Game Over si nécessaire
                    if (this.gameOver) {
                        this.drawGameOver();
                    }
                    // Overlay de pause
                    if (this.paused) {
                        this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                        this.ctx.fillRect(
                            0,
                            0,
                            this.canvas.width,
                            this.canvas.height
                        );
                        this.ctx.fillStyle = "#FFFFFF";
                        this.ctx.font = "48px Arial";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText(
                            "PAUSE",
                            this.canvas.width / 2,
                            this.canvas.height / 2
                        );
                    }

                    requestAnimationFrame((t) => this.gameLoop(t));
                }
                spawnFirstAidKit() {
                    const now = Date.now();
                    if (
                        now - this.lastFirstAidSpawn > this.firstAidSpawnRate &&
                        this.firstAidKits.length < 2
                    ) {
                        this.firstAidKits.push(new FirstAidKit(this));
                        this.lastFirstAidSpawn = now;
                    }
                }
                // Met à jour toutes les trousses de secours
                updateFirstAidKits() {
                    for (let i = this.firstAidKits.length - 1; i >= 0; i--) {
                        const kit = this.firstAidKits[i];
                        kit.update();

                        // Supprime les trousses expirées ou collectées
                        if (kit.shouldBeRemoved) {
                            this.createExplosion(kit.x, kit.y, 30, "#00FF00"); // Explosion verte
                            this.firstAidKits.splice(i, 1);
                        }
                    }
                }
                drawGameOver() {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    this.ctx.fillRect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height
                    );

                    this.ctx.fillStyle = "#FF0000";
                    this.ctx.font = "48px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText(
                        "GAME OVER",
                        this.canvas.width / 2,
                        this.canvas.height / 2 - 40
                    );

                    this.ctx.fillStyle = "#FFFFFF";
                    this.ctx.font = "24px Arial";
                    this.ctx.fillText(
                        `Score: ${this.score}`,
                        this.canvas.width / 2,
                        this.canvas.height / 2 + 20
                    );
                    this.ctx.fillText(
                        "Appuyez sur F5 pour recommencer",
                        this.canvas.width / 2,
                        this.canvas.height / 2 + 60
                    );
                }

                reset() {
                    // Réinitialiser le vaisseau
                    this.spaceship = new Spaceship(0, 0, this);

                    // Réinitialiser les ennemis et projectiles
                    this.enemies = [];
                    this.enemyProjectiles = [];
                    this.lastEnemySpawn = 0;

                    // Réinitialiser le score et l'état du jeu
                    this.score = 0;
                    this.gameOver = false;
                    this.paused = false;

                    // Réinitialiser la caméra (optionnel)
                    this.cameraOffsetX = 0;
                    this.cameraOffsetY = 0;

                    console.log("Jeu réinitialisé !");
                }
                drawGrid() {
                    const gridSize = 200;
                    const gridOpacity = 0.2;

                    const offsetX = this.cameraOffsetX % gridSize;
                    const offsetY = this.cameraOffsetY % gridSize;

                    this.ctx.strokeStyle = `rgba(50, 100, 200, ${gridOpacity})`;
                    this.ctx.lineWidth = 1;

                    // Lignes verticales
                    for (
                        let x = -offsetX;
                        x <= this.canvas.width;
                        x += gridSize
                    ) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.height);
                        this.ctx.stroke();
                    }

                    // Lignes horizontales
                    for (
                        let y = -offsetY;
                        y <= this.canvas.height;
                        y += gridSize
                    ) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.canvas.width, y);
                        this.ctx.stroke();
                    }

                    // Dessiner un grand cercle de repère au centre de l'univers
                    const distanceToOrigin = Math.sqrt(
                        this.cameraOffsetX * this.cameraOffsetX +
                            this.cameraOffsetY * this.cameraOffsetY
                    );

                    const originScreenX =
                        this.canvas.width / 2 - this.cameraOffsetX;
                    const originScreenY =
                        this.canvas.height / 2 - this.cameraOffsetY;

                    const viewRadius =
                        Math.sqrt(
                            (this.canvas.width / 2) * (this.canvas.width / 2) +
                                (this.canvas.height / 2) *
                                    (this.canvas.height / 2)
                        ) + 100;

                    if (distanceToOrigin < viewRadius) {
                        this.ctx.strokeStyle = "rgba(255, 100, 100, 0.8)";
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            originScreenX,
                            originScreenY,
                            50,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(originScreenX - 20, originScreenY);
                        this.ctx.lineTo(originScreenX + 20, originScreenY);
                        this.ctx.moveTo(originScreenX, originScreenY - 20);
                        this.ctx.lineTo(originScreenX, originScreenY + 20);
                        this.ctx.stroke();
                    }
                }

                drawCircularMinimap() {
                    if (!this.showMinimap) return;

                    const padding = 20;
                    const radius = this.minimapRadius;
                    const centerX = this.canvas.width - radius - padding;
                    const centerY = this.canvas.height - radius - padding;
                    const scale = 0.1; // Facteur d'échelle pour la minimap

                    // Fond de la minimap
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = "rgba(0, 0, 30, 0.7)";
                    this.ctx.fill();
                    this.ctx.strokeStyle = "rgba(100, 150, 255, 0.8)";
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();

                     // Vaisseau + direction
                     this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = "#00FFFF";
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                    this.ctx.fill();

                    const dirX =
                        Math.sin((this.spaceship.rotation * Math.PI) / 180) * 8;
                    const dirY =
                        -Math.cos((this.spaceship.rotation * Math.PI) / 180) *
                        8;
                    this.ctx.strokeStyle = "#00FFFF";
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(centerX + dirX, centerY + dirY);
                    this.ctx.stroke();

                    this.ctx.restore();


                    // Contour
                    this.ctx.strokeStyle = "rgba(100, 150, 255, 0.8)";
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.stroke();

                    // Dessiner les axes N, S, E, O
                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                    this.ctx.font = "12px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    this.ctx.fillText("N", centerX, centerY - radius + 8);
                    this.ctx.fillText("S", centerX, centerY + radius - 8);
                    this.ctx.fillText("E", centerX + radius - 8, centerY);
                    this.ctx.fillText("O", centerX - radius + 8, centerY);

                    const maxDetectionRange = radius / scale;
// Centre de l’univers
const relativeOriginX = -this.spaceship.x * scale;
                    const relativeOriginY = -this.spaceship.y * scale;
                    const distanceToOrigin = Math.sqrt(
                        this.spaceship.x ** 2 + this.spaceship.y ** 2
                    );
                    if (distanceToOrigin < maxDetectionRange) {
                        this.ctx.fillStyle = "rgba(255, 100, 100, 0.8)";
                        this.ctx.beginPath();
                        this.ctx.arc(
                            centerX + relativeOriginX,
                            centerY + relativeOriginY,
                            4,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    }

                    // Grille et le fond radial gradient
                    this.ctx.strokeStyle = "rgba(0, 0, 255, 0.3)";
                    this.ctx.lineWidth = 1;
                    for (let r = radius / 4; r <= radius; r += radius / 4) {
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    for (let angle = 0; angle < 360; angle += 45) {
                        const radian = (angle * Math.PI) / 180;
                        this.ctx.beginPath();
                        this.ctx.moveTo(centerX, centerY);
                        this.ctx.lineTo(
                            centerX + Math.cos(radian) * radius,
                            centerY + Math.sin(radian) * radius
                        );
                        this.ctx.stroke();
                    }

                    const gradient_bg = this.ctx.createRadialGradient(
                        centerX,
                        centerY,
                        0,
                        centerX,
                        centerY,
                        radius
                    );
                    gradient_bg.addColorStop(0, "rgba(0, 0, 255,  0.3)");
                    gradient_bg.addColorStop(1, "rgba(0, 0, 255,  0)");

                    this.ctx.fillStyle = gradient_bg;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.closePath();
                    this.ctx.fill();

                    const radarTime = Date.now() * 0.002;
                    const radarAngle = ((radarTime / 8) % 1) * Math.PI * 2;

                    // Dessiner le radar
                    this.ctx.save();
                    ///this.ctx.translate(centerX, centerY);
                    //this.ctx.rotate(radarAngle);
                    const gradient = this.ctx.createLinearGradient(
                        Math.cos(Math.PI / 8) * -radius,
                        Math.sin(Math.PI / 4),
                        Math.cos(Math.PI / 4) * radius,
                        Math.sin(Math.PI / 4) * radius
                    );
                    gradient.addColorStop(1, "rgba(0, 0, 255, .2)");
                    gradient.addColorStop(0.7, "rgba(0, 0, 255, 0.1)");
                    gradient.addColorStop(0.5, "rgba(0, 0, 255, 0)");
                    gradient.addColorStop(0, "rgba(0, 0, 255, 0)");
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(
                        0,
                        radius - centerX - padding / 2,
                        centerX,
                        centerY
                    );
                    this.ctx.restore();

                    this.ctx.strokeStyle = "rgba(0, 0, 255, 0.3)";
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(radarAngle) * radius,
                        centerY + Math.sin(radarAngle) * radius
                    );
                    this.ctx.stroke();

                    const now = Date.now();

                    
                    // Dessiner les ennemis
                    for (const enemy of this.enemies) {
                        const relX = (enemy.x - this.spaceship.x) * scale;
                        const relY = (enemy.y - this.spaceship.y) * scale;
                        const dist = Math.sqrt(relX * relX + relY * relY);

                        if (dist < radius) {
                            this.ctx.fillStyle = enemy.color;
                            this.ctx.beginPath();
                            this.ctx.arc(
                                centerX + relX,
                                centerY + relY,
                                3,
                                0,
                                Math.PI * 2
                            );
                            this.ctx.fill();
                        }
                    }

                    // Dessiner les trousses de secours
                    for (const kit of this.firstAidKits) {
                        const relativeX = (kit.x - this.spaceship.x) * scale;
                        const relativeY = (kit.y - this.spaceship.y) * scale;
                        const distance = Math.sqrt(
                            relativeX * relativeX + relativeY * relativeY
                        );

                        if (distance < radius) {
                            // Effet de pulsation pour mieux voir les trousses
                            const pulse =
                                Math.sin(Date.now() * 0.005) * 0.5 + 1;
                            this.ctx.globalAlpha = 1 - distance / radius; // Opacité en fonction de la distance
                            this.ctx.fillStyle = "rgba(0, 200, 255, 0.8)"; // Couleur de la trousse

                            this.ctx.beginPath();
                            this.ctx.arc(
                                centerX + relativeX,
                                centerY + relativeY,
                                13 * pulse, // Taille pulsée
                                0,
                                Math.PI * 2
                            );
                            this.ctx.fill();
                            this.ctx.globalAlpha = 1;
                        } else {
                        }
                    }

                    this.ctx.restore();
                }
                drawDebugInfo() {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.5)";

                    this.ctx.fillStyle = "#FFF";
                    this.ctx.font = "14px Arial";
                    debug.innerHTML = `Position du vaisseau: (${Math.round(
                        this.spaceship.x
                    )}, ${Math.round(this.spaceship.y)})`;
                    debug.innerHTML += `<br>Vitesse: ${this.spaceship.speed.toFixed(
                        2
                    )}`;
                    debug.innerHTML += `<br>Rotation: ${Math.round(
                        this.spaceship.rotation
                    )}°`;
                    debug.innerHTML += `<br>Mode souris: ${
                        this.spaceship.mouseControl ? "Activé" : "Désactivé"
                    }`;
                    debug.innerHTML += `<br>Distance du centre: ${Math.round(
                        Math.sqrt(this.spaceship.x ** 2 + this.spaceship.y ** 2)
                    )}`;
                    debug.innerHTML += `<br>Ennemis: ${this.enemies.length}`;
                    debug.innerHTML += `<br>Score: ${this.score}`;
                    debug.innerHTML += `<br>Vie: ${Math.round(
                        this.spaceship.health
                    )}/${this.spaceship.maxHealth}`;
                }
            }

            let game = new Game();
            // En dehors de la classe Game, au début du script
            window.addEventListener("keydown", function (e) {
                if (e.key === "F5" || e.keyCode === 116) {
                    e.preventDefault(); // Bloquer le rechargement natif
                    // Appeler la méthode reset() de l'instance de jeu
                }
            });
            // Pour forcer le spawn d'une trousse (débogage) :
            document.addEventListener("keydown", (e) => {
                if (e.key === "h") {
                    game.firstAidKits.push(new FirstAidKit(game));
                    console.log("Trousse de secours  !");
                }
            });
        </script>
    </body>
</html>
